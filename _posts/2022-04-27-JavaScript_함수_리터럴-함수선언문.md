---
title: "[JavaScript]함수 리터럴? 함수 선언문?"
excerpt: "Front의 기초 JS!"

categories:
    - JavaScript
tags:
    - [JavaScript, Front]
# MarkDown 문법에서 목차를 우측에 보여줄지를 결정
toc: true
# 목차부분이 마우스 스크롤시 고정으로 따라오게 할지를 결정
toc_sticky: true

date: 2022-04-27
last_modified_at: 2022-04-27
---

## 함수 리터럴? 함수 선언문?
- 함수 선언문과 함수 리터럴은 형태가 동일하지만 두 방식의 차이는 분명이 존재합니다.    
가장 큰 차이점은 **함수 리터럴은 함수 이름을 생략할 수 있지만 함수 선언문은 함수 이름을 생략할 수 없다** 입니다.   
또한 함수 선언문은 표현식이 아닌 하나의 문 입니다.

## 함수 리터럴
- 리터럴은 데이터(값) 그 자체를 뜻한다. 즉 **변수에 넣는 변하지 않는 데이터, 값 자체** 를 의미합니다.   
함수 리터럴의 특징으로는 먼저 함수의 이름을 생략할 수 있다는 것 입니다. 이런식으로 함수에 이름이 없다면   
이 함수는 **익명/무명 함수** 라고 부르게 됩니다.   
또한 함수 리터럴의 경우 해당 함수의 끝에 반드시 새미콜론(;)을 붙여야 하고,   
JavaScript엔진이 함수 선언문으로 정의한 함수는 끌어올리지만   
함수 리터럴로 정의한 함수는 끌어올리지 않기 때문에 해당 함수를 정의하지 않은 상태에서   
그 함수를 사용하려고 하면 오류가 발생합니다.   
익명/무명 함수의 경우 외부에서 해당 함수를 호출 할 수가 없습니다.   
쉽게 이야기 하면 함수 리터럴로 만든 익명/무명 함수를 사용하는 경우는    
주로 함수를 재사용 하지 않을 때 이용한다고 할 수 있습니다.
함수 리터럴을 외부에서 호출 하려면 식별자를 붙여주어 함수 외부에서도 호출이 가능해집니다.


```javascript
    // 함수 리터럴 방식 1
    var f = function bar() {
        console.log('bar');
    }

    bar();
    // ReferenceError: bar is not defined

    // 함수 리터럴 방식 2
    (function bar {
        console.log('bar');
    });

    bar();
    // ReferenceError: bar is not defined

    // 함수 리터럴 외부에서 호출하기
    var f = function bar() {
        console.log('bar');
    }

    f();
```


## 함수 선언문
- 함수 선언문의 경우는 리터럴로 선언해줄 때와 다르게 함수 이름을 생략할 수 없습니다.
또한 함수 선언문의 경우 JavaScript엔진이 함수 선언문을 프로그램의 첫 머리로 끌어올리기 때문에   
함수 선언문은 프로그램의 어떤 위치에도 작성할 수 있습니다.   
함수 선언문의 경우엔 함수 객체를 가리키는 식별자를 함수가 포함된 스코프에 암묵적으로 생성합니다.   
즉 생성된 함수를 호출하기 위해 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고 거기에 함수 객체를 할당하기 때문에   
함수 선언문으로 함수를 생성 할 경우 외부에서 함수를 호출할 수 있습니다.


```javascript
    // 함수 선언문 방식
    function bar() {
        console.log('foo');
    }

    foo();
    // foo
```
